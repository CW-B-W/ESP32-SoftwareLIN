\chapter{ESP32-\/\+Software\+LIN}
\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e}{}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e}\index{ESP32-\/SoftwareLIN@{ESP32-\/SoftwareLIN}}
\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md0}%
\Hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md0}%
\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md1}{}\doxysection{\texorpdfstring{Introduction}{Introduction}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md1}
This project is to make ESP32 support LIN (Local Interconnect Network) bus serial. ~\newline
 ESP32 doesn\textquotesingle{}t have a dedicated hardware for LIN bus communication, therefore we have to use software emulation with GPIO pins to emulate the LIN communication.\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md2}{}\doxysubsection{\texorpdfstring{Why can\textquotesingle{}t we use UART to do LIN communication?}{Why can't we use UART to do LIN communication?}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md2}
In LIN bus, the break field should consist of at least 13 dominant bits (zeros) and at least 1 recessive bits (ones). (Refer to the figure below) ~\newline
 But for UART, sending/receiving 13 consecutive zeros is considered error. ~\newline
 Therefore, generally for LIN bus communication we will need dedicated hardware in MCU to support it. ~\newline
 Refer to \href{https://www.ti.com/lit/an/slla383a/slla383a.pdf}{\texttt{ Texas Instruments -\/ LIN Protocol and Physical Layer Requirements}}

 (The signal is analyzed with \href{https://github.com/EUA/ESP32_LogicAnalyzer}{\texttt{ EUA/\+ESP32\+\_\+\+Logic\+Analyzer}})\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md3}{}\doxysubsection{\texorpdfstring{Common implementations and their limitation}{Common implementations and their limitation}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md3}
For LIN master to send a break field, a smart trick is\+: ~\newline
 When sending the break field, they halve the baud rate, and send 0x00. ~\newline
 In this way, the receiver, whose baud rate is not halved, actually receives 18 dominant bits (zeros) and 2 recessive bits (stop bits). ~\newline
 For example the implementation of \href{https://github.com/mestrode/Lin-Interface-Library/blob/76f9d4c31d0e90f9c053faf287fa81837a453ba9/src/Lin_Interface.cpp\#L229}{\texttt{ mestrode/\+Lin-\/\+Interface-\/\+Library}} ~\newline


This method should work fine for LIN master. ~\newline
 But if we use the same trick to implement LIN slave, the LIN slave cannot be flexible enough to receive all possible combinations of break field. For example, it cannot detect break field with 13 dominant bits and 1 recessive bit. ~\newline


Therefore, to make ESP32 able to be a LIN slave, this project emerges.\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md4}{}\doxysubsection{\texorpdfstring{This project}{This project}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md4}
Based on \href{https://github.com/plerup/espsoftwareserial}{\texttt{ espsoftwareserial}}, which is the software emulation of UART with GPIO pins, we add {\ttfamily break field} detection and {\ttfamily auto baud} for LIN bus. ~\newline


{\itshape {\bfseries{espsoftwareserial}}} uses GPIO pins to emulate UART. At the rising edge and falling edge of the GPIO pins, it triggers interrupt, and the ISR records the timestamp and the rising / falling edge of this interrupt. ~\newline


Making use of the timestamp and rising / falling edge information recorded by {\itshape {\bfseries{espsoftwareserial}}}, we can check whether the {\ttfamily break field} is received, no matter how many bits the {\ttfamily break field} contains. ~\newline


Using the same idea, {\ttfamily auto baud} is also implemented in this project.\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md5}{}\doxysubsubsection{\texorpdfstring{Features}{Features}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md5}

\begin{DoxyItemize}
\item Send/\+Detect break field of LIN bus
\item Autobaud detection and set
\end{DoxyItemize}\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md6}{}\doxysection{\texorpdfstring{Quick start guide}{Quick start guide}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md6}

\begin{DoxyEnumerate}
\item Use VS Code with extension Platform\+IO to open the project folder
\item Build and upload the ESP32 firmware with Platform\+IO
\begin{DoxyItemize}
\item If this device is acting as a LIN master, copy the {\ttfamily examples/master.\+cpp} to {\ttfamily src/}
\item If this device is acting as a LIN slave, copy the {\ttfamily examples/slave.\+cpp} to {\ttfamily src/}
\end{DoxyItemize}
\item Connect the UART pins of the ESP32 LIN master and ESP32 LIN slave
\end{DoxyEnumerate}\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md7}{}\doxysection{\texorpdfstring{Usage example}{Usage example}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md7}
\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md8}{}\doxysubsection{\texorpdfstring{For LIN master}{For LIN master}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md8}
Only two functions need to be used\+: {\ttfamily send\+Break()} and {\ttfamily end\+Frame()}. ~\newline
 {\ttfamily send\+Break()} is used to send the break field to the LIN bus. ~\newline
 {\ttfamily end\+Frame()} is to notify the {\ttfamily \doxylink{class_software_lin}{Software\+Lin}} the frame has ended, and it resets the internal value of {\ttfamily \doxylink{class_software_lin}{Software\+Lin}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\mbox{\hyperlink{class_software_lin}{SoftwareLin}}\ swLin(RX\_PIN,\ TX\_PIN);}
\DoxyCodeLine{swLin.begin(baud);}
\DoxyCodeLine{swLin.sendBreak();}
\DoxyCodeLine{.}
\DoxyCodeLine{.\ \textcolor{comment}{//\ Send\ data\ to\ the\ bus}}
\DoxyCodeLine{.}
\DoxyCodeLine{swLin.endFrame();}

\end{DoxyCode}
\hypertarget{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md9}{}\doxysubsection{\texorpdfstring{For LIN slave}{For LIN slave}}\label{md__2_users_2brad_2_git_hub_2_e_s_p32-_software_l_i_n_2_r_e_a_d_m_e_autotoc_md9}
Only three functions need to be used\+: {\ttfamily check\+Break()}, {\ttfamily set\+Auto\+Baud()} and {\ttfamily end\+Frame()}. ~\newline
 {\ttfamily send\+Break()} is used to check whether the break field has been detected ~\newline
 {\ttfamily set\+Auto\+Baud()} is used to automatically detect and set baud rate ~\newline
 {\ttfamily end\+Frame()} is to notify the {\ttfamily \doxylink{class_software_lin}{Software\+Lin}} the frame has ended, and it resets the internal value of {\ttfamily \doxylink{class_software_lin}{Software\+Lin}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\mbox{\hyperlink{class_software_lin}{SoftwareLin}}\ swLin(RX\_PIN,\ TX\_PIN);}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ LIN\_BAUD\_MAX\ (20000)}}
\DoxyCodeLine{swLin.begin(LIN\_BAUD\_MAX);}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ (swLin.checkBreak())\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ commonBaud[3]\ =\ \{9600,\ 14400,\ 19200\};}
\DoxyCodeLine{\ \ \ \ uint32\_t\ autobaud\ =\ swLin.setAutoBaud(commonBaud,\ 3);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (autobaud\ >\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ baud\ rate\ is\ set\ to\ autobaud}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ autobaud\ detection\ failed}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ .}
\DoxyCodeLine{\ \ \ \ .\ \textcolor{comment}{//\ Receive\ from\ the\ bus}}
\DoxyCodeLine{\ \ \ \ .\ \textcolor{comment}{//\ !!!\ Note\ that\ the\ SYNC\ byte\ was\ consumed\ by\ setAutoBaud()}}
\DoxyCodeLine{\ \ \ \ .}
\DoxyCodeLine{\ \ \ \ swLin.endFrame();}
\DoxyCodeLine{\}}

\end{DoxyCode}
 